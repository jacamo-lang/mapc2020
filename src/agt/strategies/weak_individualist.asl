/**
 * The individualist acts alone, it will try to submit tasks that it can
 * do alone. The weak individualist can carry only one block, so it will
 * only accept such simple tasks.
 */

{ include("tasks/common_task.asl") }
{ include("tasks/accept_task.asl") }
{ include("tasks/get_block.asl") }
{ include("tasks/drop_block.asl") }
{ include("tasks/submit_task.asl") }
{ include("walking/common_walking.asl") }
{ include("walking/goto_iaA_star.asl") }
{ include("simulation/watch_dog.asl") }
{ include("simulation/massim.asl") }
{ include("agentBase.asl") }
{ include("origin_workaround.asl") }

//Beliefs generated by the environment
//gps_map(X,Y,goal,_): The terrain X,Y is a goal spot
//gps_map(X,Y,B,_): There is a disposer of block B at X,Y in which (.nth(P,[b0,b1,b2,b3],B) & P >= 0)
//gps_map(X,Y,taskboard,_): There is a taskboard X,Y
//accepted(T): I am doing a task T
//attached(I,J): I have a block attached on I,J

// For rotation
rotate(cw,0,-1,1,0).  // 12 o'clock -> 3  o'clock
rotate(cw,1,0,0,1).   // 3  o'clock -> 6  o'clock
rotate(cw,0,1,-1,0).  // 6  o'clock -> 9  o'clock
rotate(cw,-1,0,0,-1). // 9  o'clock -> 12 o'clock
rotate(ccw,1,0,0,-1). // 3  o'clock -> 12  o'clock
rotate(ccw,0,1,1,0).  // 6  o'clock -> 3  o'clock
rotate(ccw,-1,0,1,0). // 9  o'clock -> 6 o'clock
rotate(ccw,0,-1,-1,0).// 12  o'clock -> 9 o'clock


+!performTask(T) :
    not accepted(_) &                       // I am not committed
    not .intend(performTask(_)) &
    .my_name(ME) &
    task(T,DL,Y,REQs) &
    .nth(0,REQs,req(_,_,B)) &   // Get the requirement (must be only one)
    task_shortest_path(B,D) &
    step(S)        
    <-
    if ( DL <= (S + D) ) { // deadline must be greater than step + shortest path
        +unwanted_task(T); // Discard tasks that are going to expire    
    } else {
        .log(warning,"I want to perform the task ",T);
        
        setWantedTask(ME,T,S,D); // no need to skip, just keep exploring until the auction ends
        .wait(step(Step) & Step > S); //wait for the next step to continue
        
        if ( wanted_task(ME,T,_,_) ) { // there is no better agent to perform this task
            -exploring;
            .log(warning,"Accepting task... ",T);
            !acceptTask(T);

            .log(warning,"Performing task... ",T);
            .nth(0,REQs,req(I,J,B));
            !getBlock(B);

            .log(warning,"Setting position of the requirement for ",T);
            !setRightPosition(req(I,J,B));

            .log(warning,"Submitting task... ",T);
            !submitTask(T);

            // In case submit did not succeed
            .log(warning,"Dropping blocks for ",T);
            !drop_all_blocks;

            //No matter if it succeed or failed, it is supposed to be ready for another task
            +exploring;
            !explore[critical_section(action), priority(1)];
        } else {
            +unwanted_task(T);
        }
    }
.
+!performTask(T)
    <-
    .log(warning,"Could not perform ",T);
.
-!performTask(T)
    <-
    .log(warning,"Failed on ",performTask(T)," dropping desire, back to explore.");
    //No matter if it succeed or failed, it is supposed to be ready for another task
    .drop_desire(performTask(_));
    +exploring;
    !explore[critical_section(action), priority(1)];
.

// This is not a single block task
+task(T,DL,Y,REQs) :
    not unwanted_task(T) &
    .length(REQs) \== 1 // The task is NOT a single block task
    <-
    +unwanted_task(T);
.

+task(T,DL,Y,REQs) :
    exploring &
    not accepted(_) &                     // I am not committed
    not unwanted_task(T) &
    .length(REQs) == 1 &
    known_requirements(T)
    <-
    .log(warning,"I am able to perform ",T);
    !!performTask(T);
.

@setRightPositionNoRotate[atomic]
+!setRightPosition(req(I,J,B)) :
    attached(I,J) // no rotation is necessary
.
@setRightPositionCWRotate_1rotation[atomic]
+!setRightPosition(REQ) :
    attached(I,J) &
    REQ = req(RI,RJ,B) &
    rotate(cw,I,J,RI,RJ) // if it is necessary 1 clockwise rotation
    <-
    !do(rotate(cw),R);
    if (R == success) {
      .log(warning,"Rotated ",B," (",I,",",J,") to (",RI,",",RJ,") dir: cw");
    } else {
      .log(warning,"Could not rotate ",B," (",I,",",J,") to (",RI,",",RJ,") dir: cw");
    }
    !setRightPosition(REQ);
.
@setRightPositionCCWRotate_1rotation[atomic]
+!setRightPosition(REQ) :
    attached(I,J) &
    REQ = req(RI,RJ,B) &
    rotate(ccw,I,J,RI,RJ) // if it is necessary 1 counterclockwise rotation
    <-
    !do(rotate(cw),R);
    if (R == success) {
      .log(warning,"Rotated ",B," (",I,",",J,") to (",RI,",",RJ,") dir: cw");
    } else {
      .log(warning,"Could not rotate ",B," (",I,",",J,") to (",RI,",",RJ,") dir: cw");
    }
    !setRightPosition(REQ);
.
@setRightPositionCCWRotate[atomic]
+!setRightPosition(REQ) :
    attached(I,J) &
    REQ = req(_,_,B) &
    rotate(ccw,NI,NJ,I,J) & // rotate counterclockwise by default
    step(S)
    <-
    !do(rotate(ccw),R0);
    if (R0 == success) {
        .log(warning,"Rotated ",B," (",I,",",J,") to (",NI,",",NJ,") dir: ccw");
    } else {
        .log(warning,"Could not rotate ",B," (",I,",",J,") to (",NI,",",NJ,") dir: ccw");
        .wait(step(Step) & Step > S); //wait for the next step to continue
        !do(rotate(cw),R1);
        if (R1 == success) {
          .log(warning,"Rotated ",B," (",I,",",J,") to (",NI,",",NJ,") dir: cw");
        } else {
          .log(warning,"Could not rotate ",B," (",I,",",J,") to (",NI,",",NJ,") dir: cw");
        }
    }
    !setRightPosition(REQ);
.
@setRightPositionFail[atomic]
+!setRightPosition(REQ) : // If other plans fail
    REQ = req(_,_,B)
    <-
    .log(warning,"No plans to rotate ",B," : ",REQ);
.

/**
 * For debugging if an unexpected error occurs
-!P[code(C),code_src(S),code_line(L),error_msg(M)] :
    true//disabled //
    <-
    .log(warning,"...");
    .log(warning,"...");
    .log(severe,"Fail on event '",C,"' of '",S,"' at line ",L,", Message: ",M);
    .log(warning,"...");
    .log(warning,"...");
    .stopMAS(0,1);
.
*/
