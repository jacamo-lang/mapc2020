/*
The individualist acts alone, it will try to submit tasks that it can do alone.
The weak individualist can carry only one block, so it will only accept such simple
tasks.
*/

{ include("$jacamoJar/templates/common-cartago.asl") }
{ include("$jacamoJar/templates/common-moise.asl") }
{ include("walking/common_walking.asl") }
{ include("walking/goto_A_star.asl") }
{ include("exploration/spiral2ExplorationStrategy.asl") }
//{ include("exploration/goal_center.asl") }
{ include("action.asl") }

//Beliefs generated by the environment
//gps_map(I,J,goal,_): The terrain I,J is a goal spot
//gps_map(I,J,B,_): There is a disposer of block B at I,J in which (.nth(P,[b0,b1,b2,b3],B) & P >= 0)
//gps_map(,I,J,taskboard,_): There is a taskboard I,J
//accepted(T): I am doing a task T
//attached(I,J): I have a block attached on I,J

// Use route planner for distances greater than 5
routeplan_mindist(5).

// For rotation
rotate(cw,0,-1,1,0).  // 12 o'clock -> 3  o'clock
rotate(cw,1,0,0,1).   // 3  o'clock -> 6  o'clock
rotate(cw,0,1,-1,0).  // 6  o'clock -> 9  o'clock
rotate(cw,-1,0,0,-1). // 9  o'clock -> 12 o'clock
rotate(ccw,1,0,0,-1). // 3  o'clock -> 12  o'clock
rotate(ccw,0,1,1,0).  // 6  o'clock -> 3  o'clock
rotate(ccw,-1,0,1,0). // 9  o'clock -> 6 o'clock
rotate(ccw,0,-1,-1,0).// 12  o'clock -> 9 o'clock

// Just to avoid plan not found
+!areyou.

/**
 * If something disturbs me but I am performing a task,
 * let's go back to this or just explore
 *
 * The agent is maybe trying to do multiple rotations in
 * order to find the right position, in this case,
 * do not interrupt!
 */
+lastAction(rotate). // Don't interrupt rotates
@lastActionPerformTask[atomic]
+lastAction(X):
    not .intend(_) &
    accepted(T) &
    task(T,DL,_,_) &
    step(S) & DL > S
    <-
    .print("Back to fulfill ",T);
    !performTask(T);
.
@lastActionExploreDetach[atomic]
+lastAction(X):
    attached(I,J) &
    directionIncrement(D,I,J)
    <-
    !do(detach(D),R1);
    if (R1 \== success) {
      .print("Fail on detaching block on ",D);
    }
    .print("Detached and let's explore the area");
.
@lastActionExplore[atomic]
+lastAction(X):
    not .intend(_)
    <-
    //.print("Let's explore the area");
    !explore(X);
.

 // Go to some random point and go back to the task board
 @performTask[atomic]
 +!performTask(T):
    task(T,DL,Y,REQs) &
    not desire(performTask(_)) &            // I am not committed
    (.length(REQs,LR) & LR == 1) &          // The task is a single block task
    .nth(0,REQs,REQ) & REQ = req(_,_,B) &   // Get the requirement (must be only one)
    task_shortest_path(B,D) &
    step(S) & DL > (S + D)                  // deadline must be greater than step + shortest path
    <-
    !gotoNearestNeighbour(taskboard);
    !acceptTask(T);
    !gotoNearestNeighbour(B);
    !getBlock(B);
    !setRightPosition(REQ);
    !gotoNearest(goal);
    !submitTask(T);
.

// Go to some random point around D far away from here (D should be even)
+!goRandomly:
    myposition(X,Y) &
    directions(LDIRECTIONS) &
    .nth(math.floor(math.random(4)),LDIRECTIONS,DR) &
    directionIncrement(DR,XINC,YINC)
    <-
    .print("Randomly going do ",DR," (",X+XINC,",",Y+YINC,")");
    !goto(X+XINC,Y+YINC);
.

// I've found a single block task
@task[atomic]
+task(T,DL,Y,REQs) :
    not desire(performTask(_)) &
    not accepted(_) &                     // I am not committed
    gps_map(_,_,taskboard,_) &            // I know a taskboard position
    gps_map(_,_,goal,_) &                 // I know a goal area position
    (.length(REQs,LR) & LR == 1) &        // The task is a single block task
    .nth(0,REQs,REQ) & REQ = req(_,_,B) & // Get the requirement (must be only one)
    gps_map(_,_,B,_) &                    // I know where to find B
    task_shortest_path(B,D) &
    step(S) & DL > (S + D)                // deadline must be greater than step + shortest path
    <-
    .succeed_goal(explore(_));
    !performTask(T);
.

/**
 * Accept a task (need to be close to a taskboard)
 */
+!acceptTask(T) :
    not accepted(_) &
    thing(_,_,taskboard,_)
    <-
    !do(accept(T),R0);
    if (R0 == success) {
      .print("Task ",T," accepted!");
    } else {
      .print("Could not accept task ",T);
    }
.
+!acceptTask(T) : // If somehow the taskboard is far away
    not accepted(_)
    <-
    !gotoNearestNeighbour(taskboard);
.
+!acceptTask(T) : accepted(T). // If this task was already accepted, just skip.

/**
 * If I know the position of at least B, find the nearest and go there!
 */
+!gotoNearest(B) :
    myposition(X,Y) &
    gps_map(_,_,B,_) &
    nearest(B,XN,YN)
    <-
    .print("Going to nearest ",B," from (",X,",",Y,") to (",XN,",",YN,")");
    !goto(XN,YN);
.

/**
 * If I know the position of at least B, find the nearest neighbour
 * point and go there!
 */
+!gotoNearestNeighbour(B) :
    myposition(X,Y) &
    gps_map(_,_,B,_) &
    nearest(B,XN,YN) &
    nearest_neighbour(XN,YN,XT,YT)
    <-
    .print("Going to nearest neighbour of ",B," from (",X,",",Y,") to (",XT,",",YT,")");
    !goto(XT,YT);
.

+!getBlock(B) :
    thing(I,J,dispenser,B) &
    directionIncrement(D,I,J) &
    not attached(_,_)
    <-
    !do(request(D),R0);
    !do(attach(D),R1);
    if ((R0 == success) & (R1 == success)) {
      .print("I have attached a block ",B);
    } else {
      .print("Could not request/attach block ",B, "::",R0,"/",R1);
    }
.
+!getBlock(B) :  // In case the agent is far away from B
    not attached(_,_)
    <-
    !gotoNearestNeighbour(B);
.
+!getBlock(B) : attached(_,_). // If I am already carrying a block B

//@setRightPositionNoRotate[atomic]
+!setRightPosition(REQ) :
    attached(I,J) &
    REQ = req(I,J,B) // no rotation is necessary
.
//@setRightPositionCWRotate[atomic]
+!setRightPosition(REQ) :
    attached(I,J) &
    REQ = req(RI,RJ,B) &
    rotate(cw,I,J,RI,RJ) // if it is necessary 1 clockwise rotation
    <-
    !do(rotate(cw),R);
    if (R == success) {
      .print("Rotated ",B," (",I,",",J,") to (",RI,",",RJ,") dir: cw");
    } else {
      .print("Could not rotate ",B," (",I,",",J,") to (",RI,",",RJ,") dir: cw");
    }
    !setRightPosition(REQ);
.
//@setRightPositionCCWRotate[atomic]
+!setRightPosition(REQ) :
    attached(I,J) &
    REQ = req(_,_,B) &
    rotate(ccw,NI,NJ,I,J) // rotate counterclockwise by default
    <-
    !do(rotate(ccw),R);
    if (R == success) {
      .print("Rotated ",B," (",I,",",J,") to (",NI,",",NJ,") dir: ccw");
    } else {
      .print("Could not rotate ",B," (",I,",",J,") to (",NI,",",NJ,") dir: ccw");
    }
    !setRightPosition(REQ);
.
//@setRightPositionFail[atomic]
+!setRightPosition(REQ) : // If other plans fail
    REQ = req(_,_,B)
    <-
    .print("No plans to rotate ",B," : ",REQ);
.

+!submitTask(T) : //thing(0,1,block,b1)
    attached(I,J) &
    directionIncrement(D,I,J) &
    task(T,DL,Y,REQs) &
    goal(0,0)         // I am over a goal
    <-
    .abolish(accepted(_));
    !do(submit(T),R0);
    if (R0 == success) {
      .print("I've submitted task ",T);
    } else {
      .fail;
    }
.
-!submitTask(T) : // Fail on submitting task
    attached(I,J) &
    directionIncrement(D,I,J)
    <-
    .print("Fail on submitting block on (",I,",",J,") task ",T," : ",REQs," : ",R0);
    !do(detach(D),R1);
    if (R1 \== success) {
      .print("Fail on detaching block on ",D);
    }
.

/**
 * Just for debugging, stop the system if an unexpected error occurs
 */
-!P[code(C),code_src(S),code_line(L),error_msg(M)] :
    true
    <-
    .log(severe,"Fail on event '",C,"' of '",S,"' at line ",L,", Message: ",M);
    .stopMAS(0,1);
.
